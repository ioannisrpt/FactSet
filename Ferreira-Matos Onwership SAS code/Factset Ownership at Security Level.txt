/* ********************************************************************************* */
/* ************************* FACTSET INSTITUTIONAL OWNERSHIP *********************** */
/* ********************************************************************************* */
/* Summary   : This application provides institutional data at a security level      */
/* Date      : July, 2020	                                                     */
/* Authors   : Miguel Ferreira, Pedro Matos, and Pedro Pires                         */
/* Details   : -International coverage                                               */
/*             -Great detail in terms of origin (domestic / foreign),                */
/*		and a few concentration measures (herfindhal, top5..)                */
/*                                                  	                             */
/* ********************************************************************************* */

* ************************************* ;
* User Defined Variables				;
* ************************************* ;
* starting quarter (YYYY0Q);
%let sqtr = 200001;

* ending quarter (YYYY0Q);
%let eqtr = 201904;

* roll forward missing reports (0/1);
%let roll = 1;

*roll 1 - takes a snapshot of the entity's last available report to fill missing reports 
in between two report dates. Each report is valid for 7 quarters;
%let n1 = 7;

*roll 2 - fills missing reports if the most recent report was filed on or after T-3;
%let n2 = 3;

%include '/home/uva/piresp/fstables_2020.sas';

* Defines WRDS (SAS) Libraries;
libname common "/wrds/factset/sasdata/common";
libname ff_usc "/wrds/factset/sasdata/ff_usc_v3";
libname ff_int "/wrds/factset/sasdata/ff_int_v3";
libname own "/wrds/factset/sasdata/own_v5";
libname piresp "/home/uva/piresp/";

* Proxy for termination date using security prices table;
proc sql;
create table termination as
select fsym_ID, max(price_date) format=YYMMDD10. as termination_date
from own.own_sec_prices_eq
group by fsym_ID;

* securities that are defined as Equity or ADR in ownership, or Preferred if defined as PREFEQ in sym_coverage;
proc sql;
create table equity_secs as
select a.fsym_id, a.issue_type, a.iso_country, b.fref_security_type
from own.own_sec_coverage_eq a left join common.sym_coverage b
on a.fsym_id eq b.fsym_id
where a.fsym_id in (select distinct fsym_id from own.own_sec_prices_eq) 
and(a.issue_type in ('EQ','AD') or (issue_type eq 'PF' and b.fref_security_type eq 'PREFEQ'));

proc sql;
create table own_basic as
select a.*, b.factset_entity_id, c.termination_date
from equity_secs a, own.own_sec_entity_eq b, termination c
where a.fsym_id eq b.fsym_id and a.fsym_id eq c.fsym_id;

* updates unadj_own_basic with main company for dual listed entities to combine; 
proc sql;
update own_basic as a
	set factset_entity_id = (
		select b.factset_entity_id from dlc b
		where a.factset_entity_id eq b.dlc_entity_id)
	where  exists (select 1 from dlc b where a.factset_entity_id eq b.dlc_entity_id);

* ..................................................................... ;
* most recent price_date within each month								;
* ..................................................................... ;
proc sql;
create table prices_historical as
select 	 a.fsym_ID, 
		 year(a.price_date)*100+month(a.price_date) as month,
		 year(a.price_date)*100+qtr(a.price_date) as quarter,
		 a.adj_shares_outstanding,
		 a.adj_price,
		 a.adj_price*a.adj_shares_outstanding/1000000 as own_mktcap
from	 own.own_sec_prices_eq a, 
		 (select fsym_ID, year(price_date)*100+month(price_date) as month, max(price_date) as maxdate
			from own.own_sec_prices_eq
			group by fsym_ID, calculated month) b
where	 (a.fsym_ID = b.fsym_ID and a.price_date = b.maxdate)
order by a.fsym_ID, calculated month;

* ......................................................................................;
* Market Cap Procedure; 
* ......................................................................................;
proc sql;
create table own_mktcap as
select fsym_ID, quarter, own_mktcap
from prices_historical
where mod(month,100) in (3,6,9,12)
and own_mktcap is not missing;

* ......................................................................................;
* 13F Reports;
* .....................................................................................;
proc sql;
create table own_inst_13f_detail as 
select factset_entity_id, fsym_id, report_date, year(report_date)*100+qtr(report_date) as quarter, adj_holding
from own.own_inst_13f_detail_eq
where calculated quarter between &sqtr and &eqtr;

proc sql;
create table max13f as
select  factset_entity_id, 
		quarter, 
		max(report_date) as maxofdlr 
from own_inst_13f_detail
group by factset_entity_id, quarter;

proc sql;
create table aux13f as
select b.*, year(b.report_date)*100+month(b.report_date) as month
from  max13f a, own_inst_13f_detail b
where a.factset_entity_id eq b.factset_entity_id
and   a.maxofdlr eq b.report_date;

proc sql;
create table v1_holdings13f as
select t1.factset_entity_id, t1.fsym_ID, t1.quarter, t1.adj_holding, t3.adj_shares_outstanding, t1.adj_holding / t3.adj_shares_outstanding as io
from aux13f t1, own_basic t2, prices_historical t3
where t1.fsym_ID eq t2.fsym_ID and t1.fsym_ID eq t3.fsym_ID and t1.month eq t3.month;

* ......................................................................................;
* Mutual Funds;
* .....................................................................................;
proc sql;
create table own_fund_detail as 
select factset_fund_id, fsym_id, report_date, year(report_date)*100+qtr(report_date) as quarter, adj_holding
from own.own_fund_detail_eq
where calculated quarter between &sqtr and &eqtr;

proc sql;
create table maxmf as
select  factset_fund_id, 
		quarter, 
		max(report_date) as maxofdlr 
from own_fund_detail
group by factset_fund_id, quarter;

proc sql;
create table auxmf as
select b.*, year(b.report_date)*100+month(b.report_date) as month
from  maxmf a, own_fund_detail b
where a.factset_fund_id eq b.factset_fund_id
and   a.maxofdlr eq b.report_date;

proc sql;
create table v1_holdingsmf as
select t1.factset_fund_id, t1.fsym_ID, t1.quarter, t1.adj_holding, t3.adj_shares_outstanding, t1.adj_holding / t3.adj_shares_outstanding as io
from auxmf t1, own_basic t2, prices_historical t3
where t1.fsym_ID eq t2.fsym_ID and t1.fsym_ID eq t3.fsym_ID and t1.month eq t3.month;

endrsubmit;

rsubmit;
/*******************************************************************/
* Imputation of Institutions Portfolios (missing reports)			; 
/*******************************************************************/
%macro imputation(flag);

%If &flag=1 %then 
	%do;

	proc fcmp outlib=sasuser.myfuncs.lionshares;
			function quarter_add(q,x);
				myear = int(q/100);
				mquarter = mod(q,10);
				years = floor(x/4);
				quarters = (x - 4 * years);
				if mquarter + quarters > 4 then result = (myear + years + 1)*100 + (mquarter + quarters - 4);
				else result = (myear + years)*100+(mquarter + quarters);
			return(result);
			endsub;
	run;
	quit;

	options cmplib=sasuser.myfuncs;
	proc sql;
	create table sym_range as
	select fsym_ID, year(termination_date)*100+qtr(termination_date) as maxofqtr
	from own_basic;

	proc sql;
	create table rangeofquarters as
	select distinct quarter from own_inst_13f_detail order by quarter;

	* 13F;
	proc sql;
	create table insts_13f as
	select distinct factset_entity_id from own_inst_13f_detail order by factset_entity_id;

	proc sql;
	create table insts_13fdates as
	select distinct factset_entity_id, quarter from insts_13f, rangeofquarters order by factset_entity_id, quarter;

	proc sql;
	create table pairs_13f as
	select distinct factset_entity_id, quarter, 1 as has_report from own_inst_13f_detail order by factset_entity_id, quarter;

	proc sql;
	create table entity_minmax as
	select factset_entity_id, min(quarter) as min_quarter, max(quarter) as max_quarter
	from own_inst_13f_detail
	group by factset_entity_id;

	proc sql;
	create table roll113f as
	select a.*,
		   case
		   	  when b.has_report is missing then 0
			  else b.has_report
		   end as has_report,
		   c.min_quarter,
		   c.max_quarter as max_quarter_raw,
		   case
		   	  when c.max_quarter >= quarter_add(&eqtr,-&n2) then &eqtr
			  else c.max_quarter
		   end as max_quarter
	from insts_13fdates a
	left join pairs_13f b on a.factset_entity_id eq b.factset_entity_id and a.quarter eq b.quarter
	inner join entity_minmax c on a.factset_entity_id eq c.factset_entity_id;

	proc sql;
	create table roll113f as select * from roll113f where quarter between min_quarter and max_quarter order by factset_entity_id, quarter;

	proc sql;
	create table roll13f as 
	select a.*, b.quarter as last_qtr, (int(a.quarter/100) - int(b.quarter/100))*4 + mod(a.quarter,100) - mod(b.quarter,100) as dif_quarters,
		   case
			  when calculated dif_quarters le &n1 then 1
			  else 0
		   end as valid
	from roll113f a, pairs_13f b
	where a.factset_entity_id eq b.factset_entity_id and b.quarter <= a.quarter
	order by a.factset_entity_id, a.quarter, b.quarter desc;

	proc sort data=roll13f nodupkey; by factset_entity_id quarter; run;

	proc sql;
	create table fill_13f as
	select *
	from roll13f
	where has_report eq 0 and valid eq 1;

	proc sql;
	create table inserts_13f as
	select b.factset_entity_id, a.quarter, b.fsym_id, b.adj_holding, b.io 
	from fill_13f a, v1_holdings13f b, sym_range c
	where a.factset_entity_id eq b.factset_entity_id and a.last_qtr eq b.quarter
	and b.fsym_id eq c.fsym_id and a.quarter lt c.maxofqtr;

	proc sql;
	create table v2_holdings13f as
	select t2.factset_rollup_entity_id as factset_entity_id, t1.fsym_id, t1.quarter, sum(t1.io) as io
	from (
			select factset_entity_id, fsym_ID, quarter, io from v1_holdings13f
			union all corr
			select factset_entity_id, fsym_ID, quarter, io from inserts_13f
		  ) t1,
		  own.own_ent_13f_combined_inst t2
	where t1.factset_entity_id eq t2.factset_filer_entity_id
	group by t2.factset_rollup_entity_id, t1.fsym_id, t1.quarter;

	* Mutual Funds;
	proc sql;
	create table insts_mf as
	select distinct factset_fund_id from own_fund_detail order by factset_fund_id;

	proc sql;
	create table insts_mfdates as
	select distinct factset_fund_id, quarter from insts_mf, rangeofquarters order by factset_fund_id, quarter;

	proc sql;
	create table pairs_mf as
	select distinct factset_fund_id, quarter, 1 as has_report from own_fund_detail order by factset_fund_id, quarter;

	proc sql;
	create table fund_minmax as
	select factset_fund_id, min(quarter) as min_quarter, max(quarter) as max_quarter
	from own_fund_detail
	group by factset_fund_id;

	proc sql;
	create table roll1mf as
	select a.*,
		   case
		   	  when b.has_report is missing then 0
			  else b.has_report
		   end as has_report,
		   c.min_quarter,
		   c.max_quarter as max_quarter_raw,
		   case
		   	  when c.max_quarter >= quarter_add(&eqtr,-&n2) then &eqtr
			  else c.max_quarter
		   end as max_quarter
	from insts_mfdates a
	left join pairs_mf b on a.factset_fund_id eq b.factset_fund_id and a.quarter eq b.quarter
	inner join fund_minmax c on a.factset_fund_id eq c.factset_fund_id;

	proc sql;
	create table roll1mf as select * from roll1mf where quarter between min_quarter and max_quarter order by factset_fund_id, quarter;

	proc sql;
	create table rollmf as 
	select a.*, b.quarter as last_qtr, (int(a.quarter/100) - int(b.quarter/100))*4 + mod(a.quarter,100) - mod(b.quarter,100) as dif_quarters,
		   case
			  when calculated dif_quarters le &n1 then 1
			  else 0
		   end as valid
	from roll1mf a, pairs_mf b
	where a.factset_fund_id eq b.factset_fund_id and b.quarter <= a.quarter
	order by a.factset_fund_id, a.quarter, b.quarter desc;

	proc sort data=rollmf nodupkey; by factset_fund_id quarter; run;

	proc sql;
	create table fill_mf as
	select *
	from rollmf
	where has_report eq 0 and valid eq 1;

	proc sql;
	create table inserts_mf as
	select b.factset_fund_id, a.quarter, b.fsym_id, b.adj_holding, b.io 
	from fill_mf a, v1_holdingsmf b, sym_range c
	where a.factset_fund_id eq b.factset_fund_id and a.last_qtr eq b.quarter
	and b.fsym_id eq c.fsym_id and a.quarter lt c.maxofqtr;

	proc sql;
	create table v2_holdingsmf as
	select factset_inst_entity_id as factset_entity_id, fsym_ID, quarter, sum(io) as io
	from (
			select factset_fund_id, fsym_ID, quarter, io from v1_holdingsmf
			union all corr
			select factset_fund_id, fsym_ID, quarter, io from inserts_mf 
		  ) t1,
			own.own_ent_funds t2
	where t1.factset_fund_id eq t2.factset_fund_id
	group by factset_entity_id, fsym_ID, quarter;

	%end;
%else 
	%do;
	proc sql;
	create table v2_holdings13f as
	select t2.factset_rollup_entity_id as factset_entity_id, t1.fsym_id, t1.quarter, sum(t1.io) as io
	from v1_holdings13f t1, own.own_ent_13f_combined_inst t2
	where t1.factset_entity_id eq t2.factset_filer_entity_id
	group by t2.factset_rollup_entity_id, t1.fsym_id, t1.quarter;

	proc sql;
	create table v2_holdingsmf as
	select t2.factset_inst_entity_id as factset_entity_id, t1.fsym_ID, t1.quarter, sum(t1.io) as io
	from v1_holdingsmf t1, own.own_ent_funds t2
	where t1.factset_fund_id eq t2.factset_fund_id
	group by t2.factset_inst_entity_id, t1.fsym_ID, t1.quarter;
	%end;
%mend;

%imputation(&roll);
/*******************************************************************/
endrsubmit;

rsubmit;
/*******************************************************************/
* Aggregates 13F with MF
- step 1 - All 13F Reports
- step 2 - All MF Reports filled by Non-13F Institutions
- For Non-US Securities keep the maximum position between 13F and MF;
/*******************************************************************/
proc sql;
create table inst_quarter_mf as
select distinct factset_entity_id, quarter from v2_holdingsmf;
create table inst_quarter_13f as
select distinct factset_entity_id, quarter from v2_holdings13f;

proc sql;
create table inst_quarter_mf_only as
select a.factset_entity_id, a.quarter
from inst_quarter_mf a
left join inst_quarter_13f b on (a.factset_entity_id = b.factset_entity_id and a.quarter = b.quarter)
where b.factset_entity_id is missing and b.quarter is missing;

proc sql;
create table inst_quarter_13f_only as
select a.factset_entity_id, a.quarter
from inst_quarter_13f a
left join inst_quarter_mf b on (a.factset_entity_id = b.factset_entity_id and a.quarter = b.quarter)
where b.factset_entity_id is missing and b.quarter is missing;

proc sql;
create table inst_quarter_both as
select a.factset_entity_id, a.quarter
from inst_quarter_mf a, inst_quarter_13f b
where a.factset_entity_id = b.factset_entity_id and a.quarter = b.quarter;

proc sql;
create table v1_holdingsall as
select factset_entity_id, fsym_ID, quarter, max(io) as io
from (
	select factset_entity_id, fsym_ID, quarter, io from v2_holdings13f

	union all corr

	select b.factset_entity_id, b.fsym_ID, b.quarter, b.io
	from inst_quarter_mf_only a, v2_holdingsmf b
	where a.factset_entity_id eq b.factset_entity_id
	and a.quarter eq b.quarter

	union all corr

	select c.factset_entity_id, c.fsym_ID, c.quarter, c.io
	from inst_quarter_both a, own_basic b, v2_holdingsmf c
	where b.iso_country ne 'US' and a.factset_entity_id = c.factset_entity_id
	and a.quarter = c.quarter and b.fsym_ID = c.fsym_ID
		)
group by factset_entity_id, fsym_ID, quarter;
/*******************************************************************/

proc sql;
create table v2_holdingsall as
select  a.factset_entity_id, a.quarter, a.fsym_id, b.factset_entity_id as company_id,
		c.iso_country as inst_country, d.iso_country as sec_country, c.entity_sub_type,
		a.io 
from v1_holdingsall a, own_basic b, common.edm_standard_entity c, common.edm_standard_entity d, own_mktcap e
where a.fsym_ID eq b.fsym_ID and a.factset_entity_id eq c.factset_entity_id
and   b.factset_entity_id eq d.factset_entity_id
and   a.fsym_ID eq e.fsym_ID and a.quarter eq e.quarter
and   b.factset_entity_id is not missing 
and   a.io is not missing
and   e.own_mktcap is not missing and e.own_mktcap ne 0
order by a.factset_entity_id, a.quarter, a.fsym_ID, b.factset_entity_id, c.entity_sub_type, c.iso_country, b.iso_country;

* adjustment factor for IO ratios gt 1;
proc sql;
create table adjfactor as
select fsym_id, quarter, sum(io) as io, max(calculated io, 1) as adjf
from v2_holdingsall group by fsym_id, quarter;

* auxiliary table with information to compute several IO metrics;
proc sql;
create table v3_holdingsall as
select  t1.fsym_id, t1.company_id, t1.quarter, t1.factset_entity_id, t1.sec_country, t1.inst_country,
		case
		   when t1.sec_country eq t1.inst_country then 1
		   else 0
		end as is_dom length=3,
		case
		   when t1.inst_country eq 'US' then 1
		   else 0
		end as is_us_inst length=3, 
		case
		  when t3.cat_institution eq 1 then 1
		  else 0
		end as is_cat1,
		case
		  when t3.cat_institution eq 2 then 1
		  else 0
		end as is_cat2,
		case
		  when t3.cat_institution eq 3 then 1
		  else 0
		end as is_cat3,
		case
		  when t3.cat_institution eq 4 then 1
		  else 0
		end as is_cat4,
		case
		  when t3.cat_institution eq 5 then 1
		  else 0
		end as is_cat5,
		case
		  when t3.cat_institution eq 6 then 1
		  else 0
		end as is_cat6,
		case
		  when t3.cat_institution eq 7 then 1
		  else 0
		end as is_cat7,
		t3.is_active,
		t1.io as io_unadj,
		t2.adjf,
		t1.io/t2.adjf as io,
		case
		   when calculated io ge 0.01 then 1
		   else 0
		end as is_mv_ibh_1pct length=3,
		case
		   when calculated io ge 0.05 then 1
		   else 0
		end as is_mv_ibh_5pct length=3
from v2_holdingsall t1, adjfactor t2, inst_type t3
where t1.fsym_id eq t2.fsym_id and t1.quarter eq t2.quarter and t1.entity_sub_type eq t3.entity_sub_type
order by t1.fsym_id, t1.quarter, calculated io desc;

proc sql;
create table v3_holdingsall as
select t1.*, 
		case 
			when t2.common_law eq 1 then 1
			else 0
		end as common_law
from v3_holdingsall t1 left join common_law t2 on (t1.inst_country eq t2.iso)
order by t1.fsym_id, t1.quarter, t1.io desc;

* ranks each institution by IO for each holding company;
data v3_holdingsall;
set v3_holdingsall;
length is_mv_top5 3;
by fsym_id quarter;
mv_top+1;
if first.quarter then mv_top=1;
if mv_top le 5 then is_mv_top5=1; else is_mv_top5=0;
run;

* computes IO metrics for each company/quarter;
proc sql;
create table holdings_by_security1 as
select 	fsym_id,  
		quarter,
		company_id,
		sec_country,
		count(*) as nbr_firms,
		sum(io) as io, 
	 	sum(io*is_dom) as io_dom,
		sum(io*(1-is_dom)) as io_for,
	 	sum(io*(1-is_dom)*is_us_inst) as io_for_us,
	 	sum(io*(1-is_dom)*(1-is_us_inst)) as io_for_nus,
		sum(io*common_law) as io_common,
		sum(io*(1-common_law)) as io_civil,
		sum(io*(1-is_dom)*common_law) as io_for_common,
		sum(io*(1-is_dom)*(1-common_law)) as io_for_civil,
		sum(io*is_mv_ibh_5pct) as ibh_5pct,
		sum(io*is_mv_ibh_1pct) as ibh_1pct,
		sum(io*is_mv_top5) as top5,
		sum(io**2)/sum(io)**2 as herf
from v3_holdingsall
group by fsym_id, quarter, company_id, sec_country;

proc sql;
create table sym_identifiers1 as
select distinct fsym_ID from holdings_by_security1;

proc sql;
create table sym_identifiers as
select a.fsym_ID,
	   case
	      when b.isin is missing then c.isin
		  else b.isin
	   end as isin,
	   d.cusip,
	   f.sedol,
	   g.ticker_region
from sym_identifiers1 a
left join common.sym_isin b
		on (a.fsym_ID eq b.fsym_ID)
left join common.sym_xc_isin c
		on (a.fsym_ID eq c.fsym_ID)
left join common.sym_cusip d
		on (a.fsym_ID eq d.fsym_ID)
left join common.sym_coverage e
		on (a.fsym_ID eq e.fsym_ID)
left join common.sym_sedol f
		on (e.fsym_primary_listing_id eq f.fsym_ID)
left join common.sym_ticker_region g
		on (e.fsym_primary_listing_id eq g.fsym_ID)
order by fsym_ID;

* merges IO metrics with market_cap and entity identifiers;
proc sql stimer;
create table holdings_by_security as
select a.fsym_ID,  
	   a.quarter,
	   intnx('month',yyq(int(a.quarter/100),mod(a.quarter,100)),2,'end') format=MMDDYY10. as rquarter,
	   a.company_id,
	   a.sec_country,
	   b.proper_name,
	   c.entity_proper_name,
	   c.primary_sic_code as header_sic,
	   b.fsym_primary_listing_id,
	   b.fref_security_type,
	   e.ticker_region as ticker,
	   e.isin,
	   e.sedol,
	   e.cusip,
	   d.own_mktcap,
	   d.own_mktcap*a.io as io_usd,
	   a.*
from holdings_by_security1 a
left join common.sym_coverage b
		on (a.fsym_id eq b.fsym_id)
left join common.edm_standard_entity c
		on (a.company_id eq c.factset_entity_id)
left join own_mktcap d
		on (a.fsym_ID eq d.fsym_ID and a.quarter eq d.quarter)
left join sym_identifiers e
	   on a.fsym_ID eq e.fsym_ID
order by a.fsym_ID, a.quarter;

* final table restricted to MSCI ACWI countries (+ Luxembourg);
* excludes REITS (sic_code eq '6798');
proc sql stimer;
create table holdings_by_security_msci as
select b.* 
from ctry a, holdings_by_security b 
where a.iso eq b.sec_country
and b.company_id not in (select factset_entity_id from common.edm_standard_entity where primary_sic_code eq '6798');